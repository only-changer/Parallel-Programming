[
  "Algorithms for calculating variance",
  "{{Short description|important algorithms in numerical statistics}} \n {{Use dmy dates|date=July 2020}} \n '''Algorithms for calculating variance''' play a major role in [[computational statistics]]. A key difficulty in the design of good [[algorithm]]s for this problem is that formulas for the [[variance]] may involve sums of squares, which can lead to [[numerical instability]] as well as to [[arithmetic overflow]] when dealing with large values. \n \n ==Na\u00efve algorithm== \n A formula for calculating the variance of an entire [[statistical population|population]] of size ''N'' is: \n \n : < math > \\sigma^2 = \\overline{(x^2)} - \\bar x^2 = \\displaystyle\\frac {\\sum_{i=1}^N x_i^2 - (\\sum_{i=1}^N x_i)^2/N}{N}. \\! < /math > \n \n Using [[Bessel's correction]] to calculate an [[estimator bias|unbiased]] estimate of the population variance from a finite [[statistical sample|sample]] of ''n'' observations, the formula is: \n \n : < math > s^2 = \\left(\\frac {\\sum_{i=1}^n x_i^2} n - \\left( \\frac {\\sum_{i=1}^n x_i} n \\right)^2\\right) \\cdot \\frac {n}{n-1}. \\! < /math > \n \n Therefore, a na\u00efve algorithm to calculate the estimated variance is given by the following: \n \n < div style= \" margin-left: 35px; width: 600px \" > \n {{framebox|blue}} \n * Let {{math|''n'' \u2190 0, Sum \u2190 0, SumSq \u2190 0}} \n * For each datum {{mvar|x}}: \n ** {{math|''n'' \u2190 ''n'' + 1}} \n ** {{math|Sum \u2190 Sum + ''x''}} \n ** {{math|SumSq \u2190 SumSq + ''x'' \u00d7 ''x''}} \n * {{math|Var {{=}} (SumSq \u2212 (Sum \u00d7 Sum) / n) / (n \u2212 1)}} \n {{frame-footer}} \n < /div > \n \n This algorithm can easily be adapted to compute the variance of a finite population: simply divide by ''N'' instead of ''n'' & nbsp;\u2212 & nbsp;1 on the last line. \n \n Because {{math|SumSq}} and {{math|(Sum\u00d7Sum)/''n''}} can be very similar numbers, [[Loss of significance|cancellation]] can lead to the [[precision (arithmetic)|precision]] of the result to be much less than the inherent precision of the [[floating-point arithmetic]] used to perform the computation.  Thus this algorithm should not be used in practice, < ref name= \" Einarsson2005 \" > {{cite book|first=Bo|last=Einarsson|title=Accuracy and Reliability in Scientific Computing|url=https://books.google.com/books?id=8hrDV5EbrEsC|year=2005|publisher=SIAM|isbn=978-0-89871-584-2|page=47}} < /ref > < ref name= \" Chan1983 \" > {{cite journal|url=http://cpsc.yale.edu/sites/default/files/files/tr222.pdf|first1=Tony F.|last1=Chan|author1-link=Tony F. Chan|first2=Gene H.|last2=Golub|author2-link=Gene H. Golub|first3=Randall J.|last3=LeVeque|title=Algorithms for computing the sample variance: Analysis and recommendations|journal=The American Statistician|volume=37|issue=3|pages=242\u2013247|year=1983|jstor=2683386|doi=10.1080/00031305.1983.10483115}} < /ref >  and several alternate, numerically stable, algorithms have been proposed. < ref name= \" :1 \" > {{Cite book|last1=Schubert|first1=Erich|last2=Gertz|first2=Michael|date=2018-07-09|title=Numerically stable parallel computation of (co-)variance|url=http://dl.acm.org/citation.cfm?id=3221269.3223036|publisher=ACM|pages=10|doi=10.1145/3221269.3223036|isbn=9781450365055|s2cid=49665540}} < /ref >  This is particularly bad if the standard deviation is small relative to the mean. However, the algorithm can be improved by adopting the method of the [[assumed mean]]. \n \n ===Computing shifted data=== \n \n The variance is [[Invariant (mathematics)|invariant]] with respect to changes in a [[location parameter]], a property which can be used to avoid the catastrophic cancellation in this formula. \n \n : < math > \\operatorname{Var}(X-K)=\\operatorname{Var}(X). < /math > \n \n with  < math > K < /math >  any constant, which leads to the new formula \n \n : < math > s^2 = \\displaystyle\\frac {\\sum_{i=1}^n (x_i-K)^2 - (\\sum_{i=1}^n (x_i-K))^2/n}{n-1}. \\! < /math > \n \n the closer  < math > K < /math >  is to the mean value the more accurate the result will be, but just choosing a value inside the \n samples range will guarantee the desired stability. If the values  < math > (x_i - K) < /math >  are small then there are no problems with the sum of its squares, on the contrary, if they are large it necessarily means that the variance is large as well. In any case the second term in the formula is always smaller than the first one therefore no cancellation may occur. < ref name= \" Chan1983 \"  / > \n \n If just the first sample is taken as  < math > K < /math >  the algorithm can be written in [[Python (programming language)|Python programming language]] as \n {{original research|date=August 2019}} \n < syntaxhighlight lang= \" python \" > \n def shifted_data_variance(data): \n     if len(data)  <  2: \n         return 0.0 \n     K = data[0] \n     n = Ex = Ex2 = 0.0 \n     for x in data: \n         n = n + 1 \n         Ex += x - K \n         Ex2 += (x - K) * (x - K) \n     variance = (Ex2 - (Ex * Ex) / n) / (n - 1) \n     # use n instead of (n-1) if want to compute the exact variance of the given data \n     # use (n-1) if data are samples of a larger population \n     return variance \n < /syntaxhighlight > \n \n This formula also facilitates the incremental computation that can be expressed as \n < syntaxhighlight lang= \" python \" > \n K = n = Ex = Ex2 = 0.0 \n \n def add_variable(x): \n     global K, n, Ex, Ex2 \n     if n == 0: \n         K = x \n     n += 1 \n     Ex += x - K \n     Ex2 += (x - K) * (x - K) \n \n def remove_variable(x): \n     global K, n, Ex, Ex2 \n     n -= 1 \n     Ex -= x - K \n     Ex2 -= (x - K) * (x - K) \n \n def get_mean(): \n     global K, n, Ex \n     return K + Ex / n \n \n def get_variance(): \n     global n, Ex, Ex2 \n     return (Ex2 - (Ex * Ex) / n) / (n - 1) \n < /syntaxhighlight > \n \n ==Two-pass algorithm== \n An alternative approach, using a different formula for the variance, first computes the sample mean, \n : < math > \\bar x = \\frac {\\sum_{j=1}^n x_j} n, < /math > \n and then computes the sum of the squares of the differences from the mean, \n : < math > \\text{sample variance} = s^2 = \\displaystyle\\frac {\\sum_{i=1}^n (x_i - \\bar x)^2}{n-1}, \\! < /math > \n where ''s'' is the standard deviation.  This is given by the following code: \n \n < syntaxhighlight lang= \" python \" > \n def two_pass_variance(data): \n     n = sum1 = sum2 = 0 \n \n     for x in data: \n         n += 1 \n         sum1 += x \n \n     mean = sum1 / n \n \n     for x in data: \n         sum2 += (x - mean) * (x - mean) \n \n     variance = sum2 / (n - 1) \n     return variance \n < /syntaxhighlight > \n \n This algorithm is numerically stable if ''n'' is small. < ref name= \" Einarsson2005 \" / > < ref > {{cite book|first=Nicholas | last=Higham |title=Accuracy and Stability of Numerical Algorithms (2 ed) (Problem 1.10)| publisher=SIAM|year=2002}} < /ref >  However, the results of both of these simple algorithms ( \" na\u00efve \"  and  \" two-pass \" ) can depend inordinately on the ordering of the data and can give poor results for very large data sets due to repeated roundoff error in the accumulation of the sums. Techniques such as [[compensated summation]] can be used to combat this error to a degree. \n \n ==Welford's online algorithm== \n It is often useful to be able to compute the variance in a [[One-pass algorithm|single pass]], inspecting each value  < math > x_i < /math >  only once; for example, when the data is being collected without enough storage to keep all the values, or when costs of memory access dominate those of computation.  For such an [[online algorithm]], a [[recurrence relation]] is required between quantities from which the required statistics can be calculated in a numerically stable fashion. \n \n The following formulas can be used to update the [[mean]] and (estimated) variance of the sequence, for an additional element ''x'' < sub > ''n'' < /sub > . Here, {{overline|''x''}} < sub > ''n'' < /sub >  denotes the sample mean of the first ''n'' samples (''x'' < sub > 1 < /sub > , ..., ''x < sub > n < /sub > ''), ''s''{{supsub|2|''n''}} their sample variance, and ''\u03c3''{{supsub|2|''n''}} their population variance. \n \n : < math > \\bar x_n = \\frac{(n-1) \\, \\bar x_{n-1} + x_n}{n} = \\bar x_{n-1} + \\frac{x_n - \\bar x_{n-1}}{n} \\! < /math > \n \n : < math > s^2_n = \\frac{n-2}{n-1} \\, s^2_{n-1} + \\frac{(x_n - \\bar x_{n-1})^2}{n} = s^2_{n-1} + \\frac{(x_n - \\bar x_{n-1})^2}{n} - \\frac{s^2_{n-1}}{n-1}, \\quad n > 1  < /math > \n \n : < math > \\sigma^2_n = \\frac{(n-1) \\, \\sigma^2_{n-1} + (x_n - \\bar x_{n-1})(x_n - \\bar x_n)}{n} = \\sigma^2_{n-1} + \\frac{(x_n - \\bar x_{n-1})(x_n - \\bar x_n) - \\sigma^2_{n-1}}{n}. < /math > \n \n These formulas suffer from numerical instability, as they repeatedly subtract a small number from a big number which scales with ''n''. A better quantity for updating is the sum of squares of differences from the current mean,  < math > \\textstyle\\sum_{i=1}^n (x_i - \\bar x_n)^2 < /math > , here denoted  < math > M_{2,n} < /math > : \n \n :  < math > \n \\begin{align} \n M_{2,n}  &  = M_{2,n-1} + (x_n - \\bar x_{n-1})(x_n - \\bar x_n) \\\\[4pt] \n s^2_n  &  = \\frac{M_{2,n}}{n-1} \\\\[4pt] \n \\sigma^2_n  &  = \\frac{M_{2,n}}{n} \n \\end{align} \n < /math > \n \n This algorithm was found by Welford, < ref > {{cite journal |first=B. P. |last=Welford |year=1962 |title=Note on a method for calculating corrected sums of squares and products |journal=[[Technometrics]] |volume=4 |issue=3 |pages=419\u2013420 |jstor=1266577 |doi=10.2307/1266577}} < /ref > < ref > [[Donald E. Knuth]] (1998). ''[[The Art of Computer Programming]]'', volume 2: ''Seminumerical Algorithms'', 3rd edn., p. & nbsp;232. Boston: Addison-Wesley. < /ref >  and it has been thoroughly analyzed. < ref name= \" Chan1983 \"  / > < ref > {{cite journal |last=Ling |first=Robert F. |year=1974 |title=Comparison of Several Algorithms for Computing Sample Means and Variances |journal=Journal of the American Statistical Association |volume=69 |issue=348 |pages=859\u2013866 |doi=10.2307/2286154|jstor=2286154 }} < /ref >  It is also common to denote  < math > M_k = \\bar x_k < /math >  and  < math > S_k = M_{2,k} < /math > . < ref > http://www.johndcook.com/standard_deviation.html < /ref > \n \n An example Python implementation for Welford's algorithm is given below. \n \n < syntaxhighlight lang= \" python \" > \n # For a new value newValue, compute the new count, new mean, the new M2. \n # mean accumulates the mean of the entire dataset \n # M2 aggregates the squared distance from the mean \n # count aggregates the number of samples seen so far \n def update(existingAggregate, newValue): \n     (count, mean, M2) = existingAggregate \n     count += 1 \n     delta = newValue - mean \n     mean += delta / count \n     delta2 = newValue - mean \n     M2 += delta * delta2 \n     return (count, mean, M2) \n \n # Retrieve the mean, variance and sample variance from an aggregate \n def finalize(existingAggregate): \n     (count, mean, M2) = existingAggregate \n     if count  <  2: \n         return float( \" nan \" ) \n     else: \n         (mean, variance, sampleVariance) = (mean, M2 / count, M2 / (count - 1)) \n         return (mean, variance, sampleVariance) \n < /syntaxhighlight > \n \n This algorithm is much less prone to loss of precision due to [[catastrophic cancellation]], but might not be as efficient because of the division operation inside the loop.  For a particularly robust two-pass algorithm for computing the variance, one can first compute and subtract an estimate of the mean, and then use this algorithm on the residuals. \n \n The [[#Parallel algorithm|parallel algorithm]] below illustrates how to merge multiple sets of statistics calculated online. \n \n ==Weighted incremental algorithm== \n The algorithm can be extended to handle unequal sample weights, replacing the simple counter ''n'' with the sum of weights seen so far.  West (1979) < ref > {{cite journal |first=D. H. D. |last=West |year=1979 |title=Updating Mean and Variance Estimates: An Improved Method |journal=[[Communications of the ACM]] |volume=22 |issue=9 |pages=532\u2013535 |doi=10.1145/359146.359153|s2cid=30671293 }} < /ref >  suggests this [[incremental algorithm]]: \n \n < syntaxhighlight lang= \" python \" > \n def weighted_incremental_variance(data_weight_pairs): \n     w_sum = w_sum2 = mean = S = 0 \n \n     for x, w in data_weight_pairs:  # Alternatively  \" for x, w in zip(data, weights): \" \n         w_sum = w_sum + w \n         w_sum2 = w_sum2 + w * w \n         mean_old = mean \n         mean = mean_old + (w / w_sum) * (x - mean_old) \n         S = S + w * (x - mean_old) * (x - mean) \n \n     population_variance = S / w_sum \n     # Bessel's correction for weighted samples \n     # Frequency weights \n     sample_frequency_variance = S / (w_sum - 1) \n     # Reliability weights \n     sample_reliability_variance = S / (w_sum - w_sum2 / w_sum) \n < /syntaxhighlight > \n \n {{further|Weighted arithmetic mean#Weighted sample variance}} \n \n ==Parallel algorithm== \n Chan et al. < ref name= \" :0 \" > {{Citation \n   | last1 = Chan     | first1 = Tony F.      | author1-link = Tony F. Chan \n   | last2 = Golub    | first2 = Gene H.      | author2-link = Gene H. Golub \n   | last3 = LeVeque  | first3 = Randall J. \n   | contribution = Updating Formulae and a Pairwise Algorithm for Computing Sample Variances. \n   | title = Technical Report STAN-CS-79-773 \n   | publisher = Department of Computer Science, Stanford University \n   | year = 1979 \n   | contribution-url =http://i.stanford.edu/pub/cstr/reports/cs/tr/79/773/CS-TR-79-773.pdf }}. < /ref >  note that Welford's online algorithm detailed above is a special case of an algorithm that works for combining arbitrary sets  < math > A < /math >  and  < math > B < /math > : \n : < math > \\begin{align} \n n_{AB}  &  = n_A + n_B \\\\ \n \\delta  &  = \\bar x_B - \\bar x_A \\\\ \n \\bar x_{AB}  &  = \\bar x_A + \\delta\\cdot\\frac{n_B}{n_{AB}} \\\\ \n M_{2,AB}  &  = M_{2,A} + M_{2,B} + \\delta^2\\cdot\\frac{n_A n_B}{n_{AB}} \\\\ \n \\end{align} < /math > . \n This may be useful when, for example, multiple processing units may be assigned to discrete parts of the input. \n \n Chan's method for estimating the mean is numerically unstable when  < math > n_A \\approx n_B < /math >  and both are large, because the numerical error in  < math > \\delta = \\bar x_B - \\bar x_A < /math >  is not scaled down in the way that it is in the  < math > n_B = 1 < /math >  case. In such cases, prefer  < math > \\bar x_{AB} = \\frac{n_A \\bar x_A + n_B \\bar x_B}{n_{AB}} < /math > . \n < syntaxhighlight lang= \" python \" > \n def parallel_variance(n_a, avg_a, M2_a, n_b, avg_b, M2_b): \n     n = n_a + n_b \n     delta = avg_b - avg_a \n     M2 = M2_a + M2_b + delta ** 2 * n_a * n_b / n \n     var_ab = M2 / (n - 1) \n     return var_ab \n < /syntaxhighlight > \n This can be generalized to allow parallelization with [[Advanced Vector Extensions|AVX]], with [[Graphics processing unit|GPUs]], and [[Computer cluster|computer clusters]], and to covariance. < ref name= \" :1 \"  / > \n \n ==Example== \n Assume that all floating point operations use standard [[IEEE 754#Double-precision 64 bit|IEEE 754 double-precision]] arithmetic. Consider the sample (4, 7, 13, 16) from an infinite population. Based on this sample, the estimated population mean is 10, and the unbiased estimate of population variance is 30.  Both the na\u00efve algorithm and two-pass algorithm compute these values correctly. \n \n Next consider the sample ({{nowrap|10 < sup > 8 < /sup > & nbsp;+ & nbsp;4}}, {{nowrap|10 < sup > 8 < /sup > & nbsp;+ & nbsp;7}}, {{nowrap|10 < sup > 8 < /sup > & nbsp;+ & nbsp;13}}, {{nowrap|10 < sup > 8 < /sup > & nbsp;+ & nbsp;16}}), which gives rise to the same estimated variance as the first sample.  The two-pass algorithm computes this variance estimate correctly, but the na\u00efve algorithm returns 29.333333333333332 instead of 30. \n \n While this loss of precision may be tolerable and viewed as a minor flaw of the na\u00efve algorithm, further increasing the offset makes the error catastrophic.  Consider the sample ({{nowrap|10 < sup > 9 < /sup > & nbsp;+ & nbsp;4}}, {{nowrap|10 < sup > 9 < /sup > & nbsp;+ & nbsp;7}}, {{nowrap|10 < sup > 9 < /sup > & nbsp;+ & nbsp;13}}, {{nowrap|10 < sup > 9 < /sup > & nbsp;+ & nbsp;16}}).  Again the estimated population variance of 30 is computed correctly by the two-pass algorithm, but the na\u00efve algorithm now computes it as \u2212170.66666666666666.  This is a serious problem with na\u00efve algorithm and is due to [[catastrophic cancellation]] in the subtraction of two similar numbers at the final stage of the algorithm. \n \n ==Higher-order statistics== \n Terriberry < ref > {{Citation \n  | last=Terriberry \n  | first=Timothy B. \n  | year=2007 \n  | title=Computing Higher-Order Moments Online \n  | url=http://people.xiph.org/~tterribe/notes/homs.html \n  | access-date=5 May 2008 \n  | archive-url=https://web.archive.org/web/20140423031833/http://people.xiph.org/~tterribe/notes/homs.html \n  | archive-date=23 April 2014 \n  | url-status=dead \n  }} < /ref >  extends Chan's formulae to calculating the third and fourth [[central moment]]s, needed for example when estimating [[skewness]] and [[kurtosis]]: \n : < math > \n \\begin{align} \n M_{3,X} = M_{3,A} + M_{3,B}  &  {} + \\delta^3\\frac{n_A n_B (n_A - n_B)}{n_X^2} + 3\\delta\\frac{n_AM_{2,B} - n_BM_{2,A}}{n_X} \\\\[6pt] \n M_{4,X} = M_{4,A} + M_{4,B}  &  {} + \\delta^4\\frac{n_A n_B \\left(n_A^2 - n_A n_B + n_B^2\\right)}{n_X^3} \\\\[6pt] \n                      &  {} + 6\\delta^2\\frac{n_A^2 M_{2,B} + n_B^2 M_{2,A}}{n_X^2} + 4\\delta\\frac{n_AM_{3,B} - n_BM_{3,A}}{n_X} \n \\end{align} < /math > \n \n Here the  < math > M_k < /math >  are again the sums of powers of differences from the mean  < math > \\sum(x - \\overline{x})^k < /math > , giving \n :  < math > \n \\begin{align} \n &  \\text{skewness} = g_1 = \\frac{\\sqrt{n} M_3}{M_2^{3/2}}, \\\\[4pt] \n &  \\text{kurtosis} = g_2 = \\frac{n M_4}{M_2^2}-3. \n \\end{align} \n < /math > \n \n For the incremental case (i.e.,  < math > B = \\{x\\} < /math > ), this simplifies to: \n :  < math > \n \\begin{align} \n \\delta  &  = x - m \\\\[5pt] \n m'  &  = m + \\frac{\\delta}{n} \\\\[5pt] \n M_2'  &  = M_2 + \\delta^2 \\frac{n-1}{n} \\\\[5pt] \n M_3'  &  = M_3 + \\delta^3 \\frac{ (n - 1) (n - 2)}{n^2} - \\frac{3\\delta M_2}{n} \\\\[5pt] \n M_4'  &  = M_4 + \\frac{\\delta^4 (n - 1) (n^2 - 3n + 3)}{n^3} + \\frac{6\\delta^2 M_2}{n^2} - \\frac{4\\delta M_3}{n} \n \\end{align} \n < /math > \n \n By preserving the value  < math > \\delta / n < /math > , only one division operation is needed and the higher-order statistics can thus be calculated for little incremental cost. \n \n An example of the online algorithm for kurtosis implemented as described is: \n < syntaxhighlight lang= \" python \" > \n def online_kurtosis(data): \n     n = mean = M2 = M3 = M4 = 0 \n \n     for x in data: \n         n1 = n \n         n = n + 1 \n         delta = x - mean \n         delta_n = delta / n \n         delta_n2 = delta_n * delta_n \n         term1 = delta * delta_n * n1 \n         mean = mean + delta_n \n         M4 = M4 + term1 * delta_n2 * (n*n - 3*n + 3) + 6 * delta_n2 * M2 - 4 * delta_n * M3 \n         M3 = M3 + term1 * delta_n * (n - 2) - 3 * delta_n * M2 \n         M2 = M2 + term1 \n \n     # Note, you may also calculate variance using M2, and skewness using M3 \n     # Caution: If all the inputs are the same, M2 will be 0, resulting in a division by 0. \n     kurtosis = (n * M4) / (M2 * M2) - 3 \n     return kurtosis \n < /syntaxhighlight > \n \n P\u00e9ba\u00ff < ref > {{Citation \n  | last=P\u00e9ba\u00ff \n  | first=Philippe \n  | year=2008 \n  | contribution=Formulas for Robust, One-Pass Parallel Computation of Covariances and Arbitrary-Order Statistical Moments \n  | title=Technical Report SAND2008-6212 \n  | publisher=Sandia National Laboratories \n  | contribution-url=http://infoserve.sandia.gov/sand_doc/2008/086212.pdf \n  }}{{Dead link|date=April 2021 |bot=InternetArchiveBot |fix-attempted=yes }} < /ref > \n further extends these results to arbitrary-order [[central moment]]s, for the incremental and the pairwise cases, and subsequently P\u00e9ba\u00ff et al. < ref > {{Citation \n  | last1=P\u00e9ba\u00ff \n  | first1=Philippe \n  | last2=Terriberry \n  | first2=Timothy \n  | last3=Kolla \n  | first3=Hemanth \n  | last4=Bennett \n  | first4=Janine \n  | year=2016 \n  | title=Numerically Stable, Scalable Formulas for Parallel and Online Computation of Higher-Order Multivariate Central Moments with Arbitrary Weights \n  | journal=Computational Statistics \n  | volume=31 \n  | issue=4 \n  | pages=1305\u20131325 \n  | publisher=Springer \n  | doi=10.1007/s00180-015-0637-z \n  | s2cid=124570169 \n  | url=https://zenodo.org/record/1232635 \n  }} < /ref > \n for weighted and compound moments. One can also find there similar formulas for [[covariance]]. \n \n Choi and Sweetman < ref name= \" Choi2010 \" > {{Citation \n  |last1  = Choi \n  |first1 = Myoungkeun \n  |last2  = Sweetman \n  |first2 = Bert \n  |s2cid = 17534100 \n  |year   = 2010 \n  |title  = Efficient Calculation of Statistical Moments for Structural Health Monitoring \n  |journal= Journal of Structural Health Monitoring \n  |volume=9 \n  |issue=1 \n  |pages=13\u201324 \n  |doi=10.1177/1475921709341014 \n }} < /ref > \n offer two alternative methods to compute the skewness and kurtosis, each of which can save substantial computer memory requirements and CPU time in certain applications. The first approach is to compute the statistical moments by separating the data into bins and then computing the moments from the geometry of the resulting histogram, which effectively becomes a [[one-pass algorithm]] for higher moments. One benefit is that the statistical moment calculations can be carried out to arbitrary accuracy such that the computations can be tuned to the precision of, e.g., the data storage format or the original measurement hardware.  A relative histogram of a random variable can be constructed in the conventional way: the range of potential values is \n divided into bins and the number of occurrences within each bin are counted and plotted such that the area of each rectangle equals the portion of the sample values within that bin: \n \n :  < math >  H(x_k)=\\frac{h(x_k)}{A} < /math > \n \n where  < math > h(x_k) < /math >  and  < math > H(x_k) < /math >  represent the frequency and the relative frequency at bin  < math > x_k < /math >  and  < math > A= \\sum_{k=1}^K h(x_k) \\,\\Delta x_k < /math >  is the total area of the histogram. After this normalization, the  < math > n < /math >  raw moments and central moments of  < math > x(t) < /math >  can be calculated from the relative histogram: \n \n :  < math > \n  m_n^{(h)} = \\sum_{k=1}^{K}  x_k^n H(x_k) \\, \\Delta x_k \n             = \\frac{1}{A} \\sum_{k=1}^K x_k^n h(x_k) \\, \\Delta x_k \n < /math > \n \n :  < math > \n  \\theta_n^{(h)}= \\sum_{k=1}^{K} \\Big(x_k-m_1^{(h)}\\Big)^n \\, H(x_k) \\, \\Delta x_k \n                = \\frac{1}{A} \\sum_{k=1}^{K} \\Big(x_k-m_1^{(h)}\\Big)^n h(x_k) \\, \\Delta x_k \n < /math > \n \n where the superscript  < math > ^{(h)} < /math >  indicates the moments are calculated from the histogram. For constant bin width  < math > \\Delta x_k=\\Delta x < /math >  these two expressions can be simplified using  < math > I= A/\\Delta x < /math > : \n \n :  < math > \n  m_n^{(h)}= \\frac{1}{I} \\sum_{k=1}^K x_k^n \\, h(x_k) \n < /math > \n \n :  < math > \n  \\theta_n^{(h)}= \\frac{1}{I} \\sum_{k=1}^K \\Big(x_k-m_1^{(h)}\\Big)^n h(x_k) \n < /math > \n \n The second approach from Choi and Sweetman < ref name= \" Choi2010 \"  / >  is an analytical methodology to combine statistical moments from individual segments of a time-history such that the resulting overall moments are those of the complete time-history. This methodology could be used for parallel computation of statistical moments with subsequent combination of those moments, or for combination of statistical moments computed at sequential times. \n \n If  < math > Q < /math >  sets of statistical moments are known: \n < math > (\\gamma_{0,q},\\mu_{q},\\sigma^2_{q},\\alpha_{3,q},\\alpha_{4,q}) \n \\quad  < /math >  for  < math > q=1,2,\\ldots,Q  < /math > , then each  < math > \\gamma_n < /math >  can \n be expressed in terms of the equivalent  < math > n < /math >  raw moments: \n \n :  < math > \n \\gamma_{n,q}= m_{n,q} \\gamma_{0,q} \\qquad \\quad \\textrm{for} \\quad n=1,2,3,4  \\quad \\text{ and } \\quad q = 1,2, \\dots ,Q \n < /math > \n \n where  < math > \\gamma_{0,q} < /math >  is generally taken to be the duration of the  < math > q^{th} < /math >  time-history, or the number of points if  < math > \\Delta t < /math >  is constant. \n \n The benefit of expressing the statistical moments in terms of  < math > \\gamma < /math >  is that the  < math > Q < /math >  sets can be combined by addition, and there is no upper limit on the value of  < math > Q < /math > . \n \n :  < math > \n  \\gamma_{n,c}= \\sum_{q=1}^Q \\gamma_{n,q} \\quad \\quad \\text{for } n=0,1,2,3,4 \n < /math > \n \n where the subscript  < math > _c < /math >  represents the concatenated time-history or combined  < math > \\gamma < /math > . These combined values of  < math > \\gamma < /math >  can then be inversely transformed into raw moments representing the complete concatenated time-history \n \n :  < math > \n  m_{n,c}=\\frac{\\gamma_{n,c}}{\\gamma_{0,c}} \\quad \\text{for } n=1,2,3,4 \n < /math > \n \n Known relationships between the raw moments ( < math > m_n < /math > ) and the central moments ( < math >  \\theta_n = \\operatorname E[(x-\\mu)^n]) < /math > ) \n are then used to compute the central moments of the concatenated time-history.  Finally, the statistical moments of the concatenated history are computed from the central moments: \n \n :  < math > \n  \\mu_c=m_{1,c} \n  \\qquad \\sigma^2_c=\\theta_{2,c} \n  \\qquad \\alpha_{3,c}=\\frac{\\theta_{3,c}}{\\sigma_c^3} \n  \\qquad \\alpha_{4,c}={\\frac{\\theta_{4,c}}{\\sigma_c^4}}-3 \n < /math > \n \n ==Covariance== \n Very similar algorithms can be used to compute the [[covariance]].   \n \n ===Na\u00efve algorithm=== \n The na\u00efve algorithm is: \n : < math > \\operatorname{Cov}(X,Y) = \\displaystyle\\frac {\\sum_{i=1}^n x_i y_i - (\\sum_{i=1}^n x_i)(\\sum_{i=1}^n y_i)/n}{n}. \\! < /math > \n \n For the algorithm above, one could use the following Python code: \n < syntaxhighlight lang= \" python \" > \n def naive_covariance(data1, data2): \n     n = len(data1) \n     sum12 = 0 \n     sum1 = sum(data1) \n     sum2 = sum(data2) \n \n     for i1, i2 in zip(data1, data2): \n         sum12 += i1 * i2 \n \n     covariance = (sum12 - sum1 * sum2 / n) / n \n     return covariance \n < /syntaxhighlight > \n \n ===With estimate of the mean=== \n As for the variance, the covariance of two random variables is also shift-invariant, so given any two constant values  < math > k_x < /math >  and  < math > k_y, < /math >  it can be written: \n \n : < math > \\operatorname{Cov}(X,Y) = \\operatorname{Cov}(X-k_x,Y-k_y) = \\displaystyle\\frac {\\sum_{i=1}^n (x_i-k_x) (y_i-k_y) - (\\sum_{i=1}^n (x_i-k_x))(\\sum_{i=1}^n (y_i-k_y))/n}{n}. \\! < /math > \n \n and again choosing a value inside the range of values will stabilize the formula against catastrophic cancellation as well as make it more robust against big sums. Taking the first value of each data set, the algorithm can be written as: \n \n < syntaxhighlight lang= \" python \" > \n def shifted_data_covariance(data_x, data_y): \n     n = len(data_x) \n     if n  <  2: \n         return 0 \n     kx = data_x[0] \n     ky = data_y[0] \n     Ex = Ey = Exy = 0 \n     for ix, iy in zip(data_x, data_y): \n         Ex += ix - kx \n         Ey += iy - ky \n         Exy += (ix - kx) * (iy - ky) \n     return (Exy - Ex * Ey / n) / n \n < /syntaxhighlight > \n \n ===Two-pass=== \n The two-pass algorithm first computes the sample means, and then the covariance: \n : < math > \\bar x = \\displaystyle \\sum_{i=1}^n x_i/n < /math > \n : < math > \\bar y = \\displaystyle \\sum_{i=1}^n y_i/n < /math > \n : < math > \\operatorname{Cov}(X,Y) = \\displaystyle\\frac {\\sum_{i=1}^n (x_i - \\bar x)(y_i - \\bar y)}{n}. \\! < /math > \n \n The two-pass algorithm may be written as: \n < syntaxhighlight lang= \" python \" > \n def two_pass_covariance(data1, data2): \n     n = len(data1) \n \n     mean1 = sum(data1) / n \n     mean2 = sum(data2) / n \n \n     covariance = 0 \n \n     for i1, i2 in zip(data1, data2): \n         a = i1 - mean1 \n         b = i2 - mean2 \n         covariance += a * b / n \n     return covariance \n < /syntaxhighlight > \n \n A slightly more accurate compensated version performs the full naive algorithm on the residuals.  The final sums  < math > \\textstyle\\sum x_i < /math >  and  < math > \\textstyle\\sum y_i < /math >  ''should'' be zero, but the second pass compensates for any small error. \n \n ===Online=== \n \n A stable one-pass algorithm exists, similar to the online algorithm for computing the variance, that computes co-moment  < math > \\textstyle C_n = \\sum_{i=1}^n (x_i - \\bar x_n)(y_i - \\bar y_n) < /math > : \n : < math > \\begin{alignat}{2} \n \\bar x_n  & = \\bar x_{n-1}  & \\,+\\, &  \\frac{x_n - \\bar x_{n-1}}{n} \\\\[5pt] \n \\bar y_n  & = \\bar y_{n-1}  & \\,+\\, &  \\frac{y_n - \\bar y_{n-1}}{n} \\\\[5pt] \n C_n       & = C_{n-1}       & \\,+\\, &  (x_n - \\bar x_n)(y_n - \\bar y_{n-1}) \\\\[5pt] \n           & = C_{n-1}       & \\,+\\, &  (x_n - \\bar x_{n-1})(y_n - \\bar y_n) \n \\end{alignat} < /math > \n The apparent asymmetry in that last equation is due to the fact that  < math > \\textstyle (x_n - \\bar x_n) = \\frac{n-1}{n}(x_n - \\bar x_{n-1}) < /math > , so both update terms are equal to  < math > \\textstyle \\frac{n-1}{n}(x_n - \\bar x_{n-1})(y_n - \\bar y_{n-1}) < /math > .  Even greater accuracy can be achieved by first computing the means, then using the stable one-pass algorithm on the residuals. \n \n Thus the covariance can be computed as \n : < math > \\begin{align} \n \\operatorname{Cov}_N(X,Y) = \\frac{C_N}{N}  & = \\frac{\\operatorname{Cov}_{N-1}(X,Y)\\cdot(N-1) + (x_n - \\bar x_n)(y_n - \\bar y_{n-1})}{N}\\\\ \n     & = \\frac{\\operatorname{Cov}_{N-1}(X,Y)\\cdot(N-1) + (x_n - \\bar x_{n-1})(y_n - \\bar y_n)}{N}\\\\ \n     & = \\frac{\\operatorname{Cov}_{N-1}(X,Y)\\cdot(N-1) + \\frac{N-1}{N}(x_n - \\bar x_{n-1})(y_n - \\bar y_{n-1})}{N}\\\\ \n     & = \\frac{\\operatorname{Cov}_{N-1}(X,Y)\\cdot(N-1) + \\frac{N}{N-1}(x_n - \\bar x_{n})(y_n - \\bar y_{n})}{N}. \n \\end{align} < /math > \n \n < syntaxhighlight lang= \" python \" > \n def online_covariance(data1, data2): \n     meanx = meany = C = n = 0 \n     for x, y in zip(data1, data2): \n         n += 1 \n         dx = x - meanx \n         meanx += dx / n \n         meany += (y - meany) / n \n         C += dx * (y - meany) \n \n     population_covar = C / n \n     # Bessel's correction for sample variance \n     sample_covar = C / (n - 1) \n < /syntaxhighlight > \n \n A small modification can also be made to compute the weighted covariance: \n \n < syntaxhighlight lang= \" python \" > \n def online_weighted_covariance(data1, data2, data3): \n     meanx = meany = 0 \n     wsum = wsum2 = 0 \n     C = 0 \n     for x, y, w in zip(data1, data2, data3): \n         wsum += w \n         wsum2 += w * w \n         dx = x - meanx \n         meanx += (w / wsum) * dx \n         meany += (w / wsum) * (y - meany) \n         C += w * dx * (y - meany) \n \n     population_covar = C / wsum \n     # Bessel's correction for sample variance \n     # Frequency weights \n     sample_frequency_covar = C / (wsum - 1) \n     # Reliability weights \n     sample_reliability_covar = C / (wsum - wsum2 / wsum) \n < /syntaxhighlight > \n \n Likewise, there is a formula for combining the covariances of two sets that can be used to parallelize the computation: < ref name= \" :1 \"  / > \n \n : < math > C_X = C_A + C_B + (\\bar x_A - \\bar x_B)(\\bar y_A - \\bar y_B)\\cdot\\frac{n_A n_B}{n_X}.  < /math > \n \n ===Weighted batched version=== \n \n A version of the weighted online algorithm that does batched updated also exists: let \n < math > w_1, \\dots w_N < /math >  denote the weights, and write \n \n : < math > \\begin{alignat}{2} \n \\bar x_{n+k}  & = \\bar x_n  & \\,+\\, &  \\frac{\\sum_{i=n+1}^{n+k} w_i (x_i - \\bar x_n)}{\\sum_{i=1}^{n+k} w_i} \\\\ \n \\bar y_{n+k}  & = \\bar y_n  & \\,+\\, &  \\frac{\\sum_{i=n+1}^{n+k} w_i (y_i - \\bar y_n)}{\\sum_{i=1}^{n+k} w_i} \\\\ \n C_{n+k}       & = C_n       & \\,+\\, &  \\sum_{i=n+1}^{n+k} w_i (x_i - \\bar x_{n+k})(y_i - \\bar y_n) \\\\ \n               & = C_n       & \\,+\\, &  \\sum_{i=n+1}^{n+k} w_i (x_i - \\bar x_n)(y_i - \\bar y_{n+k}) \\\\ \n \\end{alignat} < /math > \n \n The covariance can then be computed as \n \n : < math > \\operatorname{Cov}_N(X,Y) = \\frac{C_N}{\\sum_{i=1}^{N} w_i} < /math > \n \n ==See also== \n *[[Kahan summation algorithm]] \n *[[Squared deviations from the mean]] \n *[[Yamartino method]] \n \n ==References== \n < references / > \n \n ==External links== \n * {{MathWorld|title=Sample Variance Computation|urlname=SampleVarianceComputation}} \n \n {{DEFAULTSORT:Algorithms For Calculating Variance}} \n [[Category:Statistical algorithms]] \n [[Category:Statistical deviation and dispersion]] \n [[Category:Articles with example pseudocode]] \n [[Category:Articles with example Python (programming language) code]]"
]
